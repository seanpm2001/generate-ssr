/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
}

var start = /\n(\t+)/;
function deindent(strings) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    var indentation = start.exec(strings[0])[1];
    var pattern = new RegExp("^" + indentation, 'gm');
    var result = strings[0].replace(start, '').replace(pattern, '');
    var trailingIndentation = getTrailingIndentation(result);
    for (var i = 1; i < strings.length; i += 1) {
        var expression = values[i - 1];
        var string = strings[i].replace(pattern, '');
        if (Array.isArray(expression)) {
            expression = expression.length ? expression.join('\n') : null;
        }
        if (expression || expression === '') {
            var value = String(expression).replace(/\n/g, "\n" + trailingIndentation);
            result += value + string;
        }
        else {
            var c = result.length;
            while (/\s/.test(result[c - 1]))
                c -= 1;
            result = result.slice(0, c) + string;
        }
        trailingIndentation = getTrailingIndentation(result);
    }
    return result.trim().replace(/\t+$/gm, '');
}
function getTrailingIndentation(str) {
    var i = str.length;
    while (str[i - 1] === ' ' || str[i - 1] === '\t')
        i -= 1;
    return str.slice(i, str.length);
}

function stringify(data, options) {
    if (options === void 0) { options = {}; }
    return JSON.stringify(escape(data, options));
}
function escape(data, _a) {
    var _b = (_a === void 0 ? {} : _a).onlyEscapeAtSymbol, onlyEscapeAtSymbol = _b === void 0 ? false : _b;
    return data.replace(onlyEscapeAtSymbol ? /(%+|@+)/g : /(%+|@+|#+)/g, function (match) {
        return match + match[0];
    });
}
var escaped = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;'
};
function escapeHTML(html) {
    return String(html).replace(/[&<>]/g, function (match) { return escaped[match]; });
}
function escapeTemplate(str) {
    return str.replace(/(\${|`|\\)/g, '\\$1');
}

var globalWhitelist = new Set([
    'Array',
    'Boolean',
    'console',
    'Date',
    'decodeURI',
    'decodeURIComponent',
    'encodeURI',
    'encodeURIComponent',
    'Infinity',
    'Intl',
    'isFinite',
    'isNaN',
    'JSON',
    'Map',
    'Math',
    'NaN',
    'Number',
    'Object',
    'parseFloat',
    'parseInt',
    'Promise',
    'RegExp',
    'Set',
    'String',
    'undefined',
]);

function Comment (node, target, options) {
    if (options === void 0) { options = {}; }
    // Allow option to preserve comments, otherwise ignore
    if (options.preserveComments) {
        target.append("<!--" + node.data + "-->");
    }
}

// Reserved word lists for various dialects of the language

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u09fc\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0af9\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7b9\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab65\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc";
var nonASCIIidentifierChars = "\u200c\u200d\xb7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u0669\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u06f0-\u06f9\u0711\u0730-\u074a\u07a6-\u07b0\u07c0-\u07c9\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09e6-\u09ef\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0ae6-\u0aef\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c66-\u0c6f\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0ce6-\u0cef\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0e50-\u0e59\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1040-\u1049\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u18a9\u1920-\u192b\u1930-\u193b\u1946-\u194f\u19d0-\u19da\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1bb0-\u1bb9\u1be6-\u1bf3\u1c24-\u1c37\u1c40-\u1c49\u1c50-\u1c59\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua620-\ua629\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f1\ua8ff-\ua909\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9d0-\ua9d9\ua9e5\ua9f0-\ua9f9\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa50-\uaa59\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\uabf0-\uabf9\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by bin/generate-identifier-regex.js

// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];

// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) { return false }
    pos += set[i + 1];
    if (pos >= code) { return true }
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code, astral) {
  if (code < 65) { return code === 36 }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes)
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code, astral) {
  if (code < 48) { return code === 36 }
  if (code < 58) { return true }
  if (code < 65) { return false }
  if (code < 91) { return true }
  if (code < 97) { return code === 95 }
  if (code < 123) { return true }
  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }
  if (astral === false) { return false }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)
}

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// The `startsExpr` property is used to check if the token ends a
// `yield` expression. It is set on all token types that either can
// directly start an expression (like a quotation mark) or can
// continue an expression (like the body of a string).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var TokenType = function TokenType(label, conf) {
  if ( conf === void 0 ) conf = {};

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

function binop(name, prec) {
  return new TokenType(name, {beforeExpr: true, binop: prec})
}
var beforeExpr = {beforeExpr: true};
var startsExpr = {startsExpr: true};

// Map keyword names to token types.

var keywords$1 = {};

// Succinct definitions of keyword token types
function kw(name, options) {
  if ( options === void 0 ) options = {};

  options.keyword = name;
  return keywords$1[name] = new TokenType(name, options)
}

var types = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", {beforeExpr: true, startsExpr: true}),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", {beforeExpr: true, startsExpr: true}),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", {beforeExpr: true, startsExpr: true}),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", {beforeExpr: true, startsExpr: true}),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", {beforeExpr: true, isAssign: true}),
  assign: new TokenType("_=", {beforeExpr: true, isAssign: true}),
  incDec: new TokenType("++/--", {prefix: true, postfix: true, startsExpr: true}),
  prefix: new TokenType("!/~", {beforeExpr: true, prefix: true, startsExpr: true}),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", {beforeExpr: true}),

  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", {isLoop: true, beforeExpr: true}),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", {isLoop: true}),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", {isLoop: true}),
  _with: kw("with"),
  _new: kw("new", {beforeExpr: true, startsExpr: true}),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import"),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", {beforeExpr: true, binop: 7}),
  _instanceof: kw("instanceof", {beforeExpr: true, binop: 7}),
  _typeof: kw("typeof", {beforeExpr: true, prefix: true, startsExpr: true}),
  _void: kw("void", {beforeExpr: true, prefix: true, startsExpr: true}),
  _delete: kw("delete", {beforeExpr: true, prefix: true, startsExpr: true})
};

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};

var types$1 = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function (p) { return p.tryReadTemplateToken(); }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return
  }
  var out = this.context.pop();
  if (out === types$1.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};

types.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);
  this.exprAllowed = true;
};

types.dollarBraceL.updateContext = function() {
  this.context.push(types$1.b_tmpl);
  this.exprAllowed = true;
};

types.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);
  this.exprAllowed = true;
};

types.incDec.updateContext = function() {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = types._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&
      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))
    { this.context.push(types$1.f_expr); }
  else
    { this.context.push(types$1.f_stat); }
  this.exprAllowed = false;
};

types.backQuote.updateContext = function() {
  if (this.curContext() === types$1.q_tmpl)
    { this.context.pop(); }
  else
    { this.context.push(types$1.q_tmpl); }
  this.exprAllowed = false;
};

types.star.updateContext = function(prevType) {
  if (prevType === types._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types$1.f_expr)
      { this.context[index] = types$1.f_expr_gen; }
    else
      { this.context[index] = types$1.f_gen; }
  }
  this.exprAllowed = true;
};

types.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6) {
    if (this.value === "of" && !this.exprAllowed ||
        this.value === "yield" && this.inGeneratorContext())
      { allowed = true; }
  }
  this.exprAllowed = allowed;
};

var data = {
  "$LONE": [
    "ASCII",
    "ASCII_Hex_Digit",
    "AHex",
    "Alphabetic",
    "Alpha",
    "Any",
    "Assigned",
    "Bidi_Control",
    "Bidi_C",
    "Bidi_Mirrored",
    "Bidi_M",
    "Case_Ignorable",
    "CI",
    "Cased",
    "Changes_When_Casefolded",
    "CWCF",
    "Changes_When_Casemapped",
    "CWCM",
    "Changes_When_Lowercased",
    "CWL",
    "Changes_When_NFKC_Casefolded",
    "CWKCF",
    "Changes_When_Titlecased",
    "CWT",
    "Changes_When_Uppercased",
    "CWU",
    "Dash",
    "Default_Ignorable_Code_Point",
    "DI",
    "Deprecated",
    "Dep",
    "Diacritic",
    "Dia",
    "Emoji",
    "Emoji_Component",
    "Emoji_Modifier",
    "Emoji_Modifier_Base",
    "Emoji_Presentation",
    "Extender",
    "Ext",
    "Grapheme_Base",
    "Gr_Base",
    "Grapheme_Extend",
    "Gr_Ext",
    "Hex_Digit",
    "Hex",
    "IDS_Binary_Operator",
    "IDSB",
    "IDS_Trinary_Operator",
    "IDST",
    "ID_Continue",
    "IDC",
    "ID_Start",
    "IDS",
    "Ideographic",
    "Ideo",
    "Join_Control",
    "Join_C",
    "Logical_Order_Exception",
    "LOE",
    "Lowercase",
    "Lower",
    "Math",
    "Noncharacter_Code_Point",
    "NChar",
    "Pattern_Syntax",
    "Pat_Syn",
    "Pattern_White_Space",
    "Pat_WS",
    "Quotation_Mark",
    "QMark",
    "Radical",
    "Regional_Indicator",
    "RI",
    "Sentence_Terminal",
    "STerm",
    "Soft_Dotted",
    "SD",
    "Terminal_Punctuation",
    "Term",
    "Unified_Ideograph",
    "UIdeo",
    "Uppercase",
    "Upper",
    "Variation_Selector",
    "VS",
    "White_Space",
    "space",
    "XID_Continue",
    "XIDC",
    "XID_Start",
    "XIDS"
  ],
  "General_Category": [
    "Cased_Letter",
    "LC",
    "Close_Punctuation",
    "Pe",
    "Connector_Punctuation",
    "Pc",
    "Control",
    "Cc",
    "cntrl",
    "Currency_Symbol",
    "Sc",
    "Dash_Punctuation",
    "Pd",
    "Decimal_Number",
    "Nd",
    "digit",
    "Enclosing_Mark",
    "Me",
    "Final_Punctuation",
    "Pf",
    "Format",
    "Cf",
    "Initial_Punctuation",
    "Pi",
    "Letter",
    "L",
    "Letter_Number",
    "Nl",
    "Line_Separator",
    "Zl",
    "Lowercase_Letter",
    "Ll",
    "Mark",
    "M",
    "Combining_Mark",
    "Math_Symbol",
    "Sm",
    "Modifier_Letter",
    "Lm",
    "Modifier_Symbol",
    "Sk",
    "Nonspacing_Mark",
    "Mn",
    "Number",
    "N",
    "Open_Punctuation",
    "Ps",
    "Other",
    "C",
    "Other_Letter",
    "Lo",
    "Other_Number",
    "No",
    "Other_Punctuation",
    "Po",
    "Other_Symbol",
    "So",
    "Paragraph_Separator",
    "Zp",
    "Private_Use",
    "Co",
    "Punctuation",
    "P",
    "punct",
    "Separator",
    "Z",
    "Space_Separator",
    "Zs",
    "Spacing_Mark",
    "Mc",
    "Surrogate",
    "Cs",
    "Symbol",
    "S",
    "Titlecase_Letter",
    "Lt",
    "Unassigned",
    "Cn",
    "Uppercase_Letter",
    "Lu"
  ],
  "Script": [
    "Adlam",
    "Adlm",
    "Ahom",
    "Anatolian_Hieroglyphs",
    "Hluw",
    "Arabic",
    "Arab",
    "Armenian",
    "Armn",
    "Avestan",
    "Avst",
    "Balinese",
    "Bali",
    "Bamum",
    "Bamu",
    "Bassa_Vah",
    "Bass",
    "Batak",
    "Batk",
    "Bengali",
    "Beng",
    "Bhaiksuki",
    "Bhks",
    "Bopomofo",
    "Bopo",
    "Brahmi",
    "Brah",
    "Braille",
    "Brai",
    "Buginese",
    "Bugi",
    "Buhid",
    "Buhd",
    "Canadian_Aboriginal",
    "Cans",
    "Carian",
    "Cari",
    "Caucasian_Albanian",
    "Aghb",
    "Chakma",
    "Cakm",
    "Cham",
    "Cherokee",
    "Cher",
    "Common",
    "Zyyy",
    "Coptic",
    "Copt",
    "Qaac",
    "Cuneiform",
    "Xsux",
    "Cypriot",
    "Cprt",
    "Cyrillic",
    "Cyrl",
    "Deseret",
    "Dsrt",
    "Devanagari",
    "Deva",
    "Duployan",
    "Dupl",
    "Egyptian_Hieroglyphs",
    "Egyp",
    "Elbasan",
    "Elba",
    "Ethiopic",
    "Ethi",
    "Georgian",
    "Geor",
    "Glagolitic",
    "Glag",
    "Gothic",
    "Goth",
    "Grantha",
    "Gran",
    "Greek",
    "Grek",
    "Gujarati",
    "Gujr",
    "Gurmukhi",
    "Guru",
    "Han",
    "Hani",
    "Hangul",
    "Hang",
    "Hanunoo",
    "Hano",
    "Hatran",
    "Hatr",
    "Hebrew",
    "Hebr",
    "Hiragana",
    "Hira",
    "Imperial_Aramaic",
    "Armi",
    "Inherited",
    "Zinh",
    "Qaai",
    "Inscriptional_Pahlavi",
    "Phli",
    "Inscriptional_Parthian",
    "Prti",
    "Javanese",
    "Java",
    "Kaithi",
    "Kthi",
    "Kannada",
    "Knda",
    "Katakana",
    "Kana",
    "Kayah_Li",
    "Kali",
    "Kharoshthi",
    "Khar",
    "Khmer",
    "Khmr",
    "Khojki",
    "Khoj",
    "Khudawadi",
    "Sind",
    "Lao",
    "Laoo",
    "Latin",
    "Latn",
    "Lepcha",
    "Lepc",
    "Limbu",
    "Limb",
    "Linear_A",
    "Lina",
    "Linear_B",
    "Linb",
    "Lisu",
    "Lycian",
    "Lyci",
    "Lydian",
    "Lydi",
    "Mahajani",
    "Mahj",
    "Malayalam",
    "Mlym",
    "Mandaic",
    "Mand",
    "Manichaean",
    "Mani",
    "Marchen",
    "Marc",
    "Masaram_Gondi",
    "Gonm",
    "Meetei_Mayek",
    "Mtei",
    "Mende_Kikakui",
    "Mend",
    "Meroitic_Cursive",
    "Merc",
    "Meroitic_Hieroglyphs",
    "Mero",
    "Miao",
    "Plrd",
    "Modi",
    "Mongolian",
    "Mong",
    "Mro",
    "Mroo",
    "Multani",
    "Mult",
    "Myanmar",
    "Mymr",
    "Nabataean",
    "Nbat",
    "New_Tai_Lue",
    "Talu",
    "Newa",
    "Nko",
    "Nkoo",
    "Nushu",
    "Nshu",
    "Ogham",
    "Ogam",
    "Ol_Chiki",
    "Olck",
    "Old_Hungarian",
    "Hung",
    "Old_Italic",
    "Ital",
    "Old_North_Arabian",
    "Narb",
    "Old_Permic",
    "Perm",
    "Old_Persian",
    "Xpeo",
    "Old_South_Arabian",
    "Sarb",
    "Old_Turkic",
    "Orkh",
    "Oriya",
    "Orya",
    "Osage",
    "Osge",
    "Osmanya",
    "Osma",
    "Pahawh_Hmong",
    "Hmng",
    "Palmyrene",
    "Palm",
    "Pau_Cin_Hau",
    "Pauc",
    "Phags_Pa",
    "Phag",
    "Phoenician",
    "Phnx",
    "Psalter_Pahlavi",
    "Phlp",
    "Rejang",
    "Rjng",
    "Runic",
    "Runr",
    "Samaritan",
    "Samr",
    "Saurashtra",
    "Saur",
    "Sharada",
    "Shrd",
    "Shavian",
    "Shaw",
    "Siddham",
    "Sidd",
    "SignWriting",
    "Sgnw",
    "Sinhala",
    "Sinh",
    "Sora_Sompeng",
    "Sora",
    "Soyombo",
    "Soyo",
    "Sundanese",
    "Sund",
    "Syloti_Nagri",
    "Sylo",
    "Syriac",
    "Syrc",
    "Tagalog",
    "Tglg",
    "Tagbanwa",
    "Tagb",
    "Tai_Le",
    "Tale",
    "Tai_Tham",
    "Lana",
    "Tai_Viet",
    "Tavt",
    "Takri",
    "Takr",
    "Tamil",
    "Taml",
    "Tangut",
    "Tang",
    "Telugu",
    "Telu",
    "Thaana",
    "Thaa",
    "Thai",
    "Tibetan",
    "Tibt",
    "Tifinagh",
    "Tfng",
    "Tirhuta",
    "Tirh",
    "Ugaritic",
    "Ugar",
    "Vai",
    "Vaii",
    "Warang_Citi",
    "Wara",
    "Yi",
    "Yiii",
    "Zanabazar_Square",
    "Zanb"
  ]
};
Array.prototype.push.apply(data.$LONE, data.General_Category);
data.gc = data.General_Category;
data.sc = data.Script_Extensions = data.scx = data.Script;

// Adapted from https://github.com/acornjs/acorn/blob/6584815dca7440e00de841d1dad152302fdd7ca5/src/tokenize.js
// Reproduced under MIT License https://github.com/acornjs/acorn/blob/master/LICENSE
function fullCharCodeAt(str, i) {
    var code = str.charCodeAt(i);
    if (code <= 0xd7ff || code >= 0xe000)
        return code;
    var next = str.charCodeAt(i + 1);
    return (code << 10) + next - 0x35fdc00;
}

function isValidIdentifier(str) {
    var i = 0;
    while (i < str.length) {
        var code = fullCharCodeAt(str, i);
        if (!(i === 0 ? isIdentifierStart : isIdentifierChar)(code, true))
            return false;
        i += code <= 0xffff ? 1 : 2;
    }
    return true;
}

function quoteNameIfNecessary(name) {
    if (!isValidIdentifier(name))
        return "\"" + name + "\"";
    return name;
}
function quotePropIfNecessary(name) {
    if (!isValidIdentifier(name))
        return "[\"" + name + "\"]";
    return "." + name;
}

function getObject(node) {
    while (node.type === 'MemberExpression')
        node = node.object;
    return node;
}

function getTailSnippet(node) {
    var end = node.end;
    while (node.type === 'MemberExpression')
        node = node.object;
    var start = node.end;
    return "[\u2702" + start + "-" + end + "\u2702]";
}

function Component (node, target) {
    function stringifyAttribute(chunk) {
        if (chunk.type === 'Text') {
            return escapeTemplate(escape(chunk.data));
        }
        return '${@escape( ' + chunk.snippet + ')}';
    }
    var bindingProps = node.bindings.map(function (binding) {
        var name = getObject(binding.value.node).name;
        var tail = binding.value.node.type === 'MemberExpression'
            ? getTailSnippet(binding.value.node)
            : '';
        return quoteNameIfNecessary(binding.name) + ": ctx" + quotePropIfNecessary(name) + tail;
    });
    function getAttributeValue(attribute) {
        if (attribute.isTrue)
            return "true";
        if (attribute.chunks.length === 0)
            return "''";
        if (attribute.chunks.length === 1) {
            var chunk = attribute.chunks[0];
            if (chunk.type === 'Text') {
                return stringify(chunk.data);
            }
            return chunk.snippet;
        }
        return '`' + attribute.chunks.map(stringifyAttribute).join('') + '`';
    }
    var usesSpread = node.attributes.find(function (attr) { return attr.isSpread; });
    var props = usesSpread
        ? "Object.assign(" + node.attributes
            .map(function (attribute) {
            if (attribute.isSpread) {
                return attribute.expression.snippet;
            }
            else {
                return "{ " + quoteNameIfNecessary(attribute.name) + ": " + getAttributeValue(attribute) + " }";
            }
        })
            .concat(bindingProps.map(function (p) { return "{ " + p + " }"; }))
            .join(', ') + ")"
        : "{ " + node.attributes
            .map(function (attribute) { return quoteNameIfNecessary(attribute.name) + ": " + getAttributeValue(attribute); })
            .concat(bindingProps)
            .join(', ') + " }";
    var expression = (node.name === 'svelte:self'
        ? node.compiler.name
        : node.name === 'svelte:component'
            ? "((" + node.expression.snippet + ") || @missingComponent)"
            : "%components-" + node.name);
    node.bindings.forEach(function (binding) {
        var conditions = [];
        var parent = node;
        while (parent = parent.parent) {
            if (parent.type === 'IfBlock') {
                // TODO handle contextual bindings...
                conditions.push("(" + parent.expression.snippet + ")");
            }
        }
        conditions.push("!('" + binding.name + "' in ctx)", expression + ".data");
        var name = getObject(binding.value.node).name;
        target.bindings.push(deindent(templateObject_1 || (templateObject_1 = __makeTemplateObject(["\n\t\t\tif (", ") {\n\t\t\t\ttmp = ", ".data();\n\t\t\t\tif ('", "' in tmp) {\n\t\t\t\t\tctx", " = tmp.", ";\n\t\t\t\t\tsettled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t"], ["\n\t\t\tif (", ") {\n\t\t\t\ttmp = ", ".data();\n\t\t\t\tif ('", "' in tmp) {\n\t\t\t\t\tctx", " = tmp.", ";\n\t\t\t\t\tsettled = false;\n\t\t\t\t}\n\t\t\t}\n\t\t"])), conditions.reverse().join('&&'), expression, name, quotePropIfNecessary(binding.name), name));
    });
    var open = "${@validateSsrComponent(" + expression + ", '" + node.name + "')._render(__result, " + props;
    var options = [];
    options.push("store: options.store");
    if (node.children.length) {
        var appendTarget_1 = {
            slots: { "default": '' },
            slotStack: ['default']
        };
        target.appendTargets.push(appendTarget_1);
        fragment$1(node.children, target);
        var slotted = Object.keys(appendTarget_1.slots)
            .map(function (name) { return quoteNameIfNecessary(name) + ": () => `" + appendTarget_1.slots[name] + "`"; })
            .join(', ');
        options.push("slotted: { " + slotted + " }");
        target.appendTargets.pop();
    }
    if (options.length) {
        open += ", { " + options.join(', ') + " }";
    }
    target.append(open);
    target.append(')}');
}
var templateObject_1;

function EachBlock (node, target) {
    var snippet = node.expression.snippet;
    var props = node.contexts.map(function (prop) { return prop.key.name + ": item" + prop.tail; });
    var getContext = node.index
        ? "(item, i) => Object.assign({}, ctx, { " + props.join(', ') + ", " + node.index + ": i })"
        : "item => Object.assign({}, ctx, { " + props.join(', ') + " })";
    var open = "${ " + (node["else"] ? snippet + ".length ? " : '') + "@each(" + snippet + ", " + getContext + ", ctx => `";
    target.append(open);
    fragment$1(node.children, target);
    var close = "`)";
    target.append(close);
    if (node["else"]) {
        target.append(" : `");
        fragment$1(node["else"].children, target);
        target.append("`");
    }
    target.append('}');
}

var voidElementNames = /^(?:area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/;
function isVoidElementName(name) {
    return voidElementNames.test(name) || name.toLowerCase() === '!doctype';
}

// source: https://gist.github.com/ArjanSchouten/0b8574a6ad7f5065a5e7
var booleanAttributes = new Set([
    'async',
    'autocomplete',
    'autofocus',
    'autoplay',
    'border',
    'challenge',
    'checked',
    'compact',
    'contenteditable',
    'controls',
    'default',
    'defer',
    'disabled',
    'formnovalidate',
    'frameborder',
    'hidden',
    'indeterminate',
    'ismap',
    'loop',
    'multiple',
    'muted',
    'nohref',
    'noresize',
    'noshade',
    'novalidate',
    'nowrap',
    'open',
    'readonly',
    'required',
    'reversed',
    'scoped',
    'scrolling',
    'seamless',
    'selected',
    'sortable',
    'spellcheck',
    'translate'
]);
function Element (node, target) {
    var openingTag = "<" + node.name;
    var textareaContents; // awkward special case
    var slot = node.getStaticAttributeValue('slot');
    if (slot && node.hasAncestor('Component')) {
        var slot_1 = node.attributes.find(function (attribute) { return attribute.name === 'slot'; });
        var slotName = slot_1.chunks[0].data;
        var appendTarget = target.appendTargets[target.appendTargets.length - 1];
        appendTarget.slotStack.push(slotName);
        appendTarget.slots[slotName] = '';
    }
    var classExpr = node.classes.map(function (classDir) {
        var expression = classDir.expression, name = classDir.name;
        var snippet = expression ? expression.snippet : "ctx" + quotePropIfNecessary(name);
        return snippet + " ? \"" + name + "\" : \"\"";
    }).join(', ');
    var addClassAttribute = classExpr ? true : false;
    if (node.attributes.find(function (attr) { return attr.isSpread; })) {
        // TODO dry this out
        var args_1 = [];
        node.attributes.forEach(function (attribute) {
            if (attribute.isSpread) {
                args_1.push(attribute.expression.snippet);
            }
            else {
                if (attribute.name === 'value' && node.name === 'textarea') {
                    textareaContents = attribute.stringifyForSsr();
                }
                else if (attribute.isTrue) {
                    args_1.push("{ " + quoteNameIfNecessary(attribute.name) + ": true }");
                }
                else if (booleanAttributes.has(attribute.name) &&
                    attribute.chunks.length === 1 &&
                    attribute.chunks[0].type !== 'Text') {
                    // a boolean attribute with one non-Text chunk
                    args_1.push("{ " + quoteNameIfNecessary(attribute.name) + ": " + attribute.chunks[0].snippet + " }");
                }
                else {
                    args_1.push("{ " + quoteNameIfNecessary(attribute.name) + ": `" + attribute.stringifyForSsr() + "` }");
                }
            }
        });
        openingTag += "${@spread([" + args_1.join(', ') + "])}";
    }
    else {
        node.attributes.forEach(function (attribute) {
            if (attribute.type !== 'Attribute')
                return;
            if (attribute.name === 'value' && node.name === 'textarea') {
                textareaContents = attribute.stringifyForSsr();
            }
            else if (attribute.isTrue) {
                openingTag += " " + attribute.name;
            }
            else if (booleanAttributes.has(attribute.name) &&
                attribute.chunks.length === 1 &&
                attribute.chunks[0].type !== 'Text') {
                // a boolean attribute with one non-Text chunk
                openingTag += '${' + attribute.chunks[0].snippet + ' ? " ' + attribute.name + '" : "" }';
            }
            else if (attribute.name === 'class' && classExpr) {
                addClassAttribute = false;
                openingTag += " class=\"${ [`" + attribute.stringifyForSsr() + "`, " + classExpr + " ].join(' ').trim() }\"";
            }
            else {
                openingTag += " " + attribute.name + "=\"" + attribute.stringifyForSsr() + "\"";
            }
        });
    }
    if (addClassAttribute) {
        openingTag += " class=\"${ [" + classExpr + "].join(' ').trim() }\"";
    }
    openingTag += '>';
    target.append(openingTag);
    if (node.name === 'textarea' && textareaContents !== undefined) {
        target.append(textareaContents);
    }
    else {
        fragment$1(node.children, target);
    }
    if (!isVoidElementName(node.name)) {
        target.append("</" + node.name + ">");
    }
}

function Head (node, target) {
    target.append('${(__result.head += `');
    fragment$1(node.children, target);
    target.append('`, "")}');
}

function HtmlTag (node, target) {
    target.append('${' + node.expression.snippet + '}');
}

function IfBlock (node, target) {
    var snippet = node.expression.snippet;
    target.append('${ ' + snippet + ' ? `');
    fragment$1(node.children, target);
    target.append('` : `');
    if (node["else"]) {
        fragment$1(node["else"].children, target);
    }
    target.append('` }');
}

function Slot (node, target) {
    var name = node.attributes.find(function (attribute) { return attribute.name === 'name'; });
    var slotName = name && name.chunks[0].data || 'default';
    var prop = quotePropIfNecessary(slotName);
    target.append("${options && options.slotted && options.slotted" + prop + " ? options.slotted" + prop + "() : `");
    fragment$1(node.children, target);
    target.append("`}");
}

function Tag (node, target) {
    target.append(node.parent &&
        node.parent.type === 'Element' &&
        node.parent.name === 'style'
        ? '${' + node.expression.snippet + '}'
        : '${@escape(' + node.expression.snippet + ')}');
}

function Text (node, target) {
    var text = node.data;
    if (!node.parent ||
        node.parent.type !== 'Element' ||
        (node.parent.name !== 'script' && node.parent.name !== 'style')) {
        // unless this Text node is inside a <script> or <style> element, escape &,<,>
        text = escapeHTML(text);
    }
    target.append(escape(escapeTemplate(text)));
}

function Title (node, target) {
    target.append("<title>");
    fragment$1(node.children, target);
    target.append("</title>");
}

function noop() { }
var handlers = {
    AwaitBlock: AwaitBlock,
    Comment: Comment,
    Component: Component,
    EachBlock: EachBlock,
    Element: Element,
    Head: Head,
    IfBlock: IfBlock,
    MustacheTag: Tag,
    RawMustacheTag: HtmlTag,
    Slot: Slot,
    Text: Text,
    Title: Title,
    Window: noop
};
function fragment (nodes, target) {
    nodes.forEach(function (node) {
        var handler = handlers[node.type];
        if (!handler) {
            throw new Error("No handler for '" + node.type + "' nodes");
        }
        handler(node, target);
    });
}

function AwaitBlock (node, target) {
    var snippet = node.expression.snippet;
    target.append('${(function(__value) { if(@isPromise(__value)) return `');
    fragment(node.pending.children, target);
    target.append('`; return function(ctx) { return `');
    fragment(node.then.children, target);
    target.append("`;}(Object.assign({}, ctx, { " + node.value + ": __value }));}(" + snippet + ")) }");
}

function noop$1() { }
var handlers$1 = {
    AwaitBlock: AwaitBlock,
    Comment: Comment,
    Component: Component,
    EachBlock: EachBlock,
    Element: Element,
    Head: Head,
    IfBlock: IfBlock,
    MustacheTag: Tag,
    RawMustacheTag: HtmlTag,
    Slot: Slot,
    Text: Text,
    Title: Title,
    Window: noop$1
};
function fragment$1 (nodes, target) {
    nodes.forEach(function (node) {
        var handler = handlers$1[node.type];
        if (!handler) {
            throw new Error("No handler for '" + node.type + "' nodes");
        }
        handler(node, target);
    });
}

var SsrTarget = /** @class */ (function () {
    function SsrTarget() {
        this.bindings = [];
        this.renderCode = '';
        this.appendTargets = [];
    }
    SsrTarget.prototype.append = function (code) {
        if (this.appendTargets.length) {
            var appendTarget = this.appendTargets[this.appendTargets.length - 1];
            var slotName = appendTarget.slotStack[appendTarget.slotStack.length - 1];
            appendTarget.slots[slotName] += code;
        }
        else {
            this.renderCode += code;
        }
    };
    return SsrTarget;
}());
function generate(compiler) {
    var target = new SsrTarget();
    var computations = compiler.computations, name = compiler.name, templateProperties = compiler.templateProperties;
    // create main render() function
    fragment$1(trim(compiler.fragment.children), target);
    // trim(compiler.fragment.children).forEach((node: Node) => {
    // 	node.ssr(target);
    // });
    var css = compiler.customElement ?
        { code: null, map: null } :
        compiler.stylesheet.render(compiler.options.filename, true);
    // generate initial state object
    var expectedProperties = Array.from(compiler.expectedProperties);
    var globals = expectedProperties.filter(function (prop) { return globalWhitelist.has(prop); });
    var storeProps = expectedProperties.filter(function (prop) { return prop[0] === '$'; });
    var initialState = [];
    if (globals.length > 0) {
        initialState.push("{ " + globals.map(function (prop) { return prop + " : " + prop; }).join(', ') + " }");
    }
    if (storeProps.length > 0) {
        var initialize = "_init([" + storeProps.map(function (prop) { return "\"" + prop.slice(1) + "\""; }) + "])";
        initialState.push("options.store." + initialize);
    }
    if (templateProperties.data) {
        initialState.push("%data()");
    }
    else if (globals.length === 0 && storeProps.length === 0) {
        initialState.push('{}');
    }
    initialState.push('ctx');
    // TODO concatenate CSS maps
    var result = deindent(templateObject_2 || (templateObject_2 = __makeTemplateObject(["\n\t\t", "\n\n\t\tvar ", " = {};\n\n\t\t", ";\n\n\t\t", ".data = function() {\n\t\t\treturn ", ";\n\t\t};\n\n\t\t", ".render = function(state, options = {}) {\n\t\t\tvar components = new Set();\n\n\t\t\tfunction addComponent(component) {\n\t\t\t\tcomponents.add(component);\n\t\t\t}\n\n\t\t\tvar result = { head: '', addComponent };\n\t\t\tvar html = ", "._render(result, state, options);\n\n\t\t\tvar cssCode = Array.from(components).map(c => c.css && c.css.code).filter(Boolean).join('\\n');\n\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\thead: result.head,\n\t\t\t\tcss: { code: cssCode, map: null },\n\t\t\t\ttoString() {\n\t\t\t\t\treturn html;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t", "._render = function(__result, ctx, options) {\n\t\t\t", "\n\t\t\t__result.addComponent(", ");\n\n\t\t\tctx = Object.assign(", ");\n\n\t\t\t", "\n\n\t\t\t", "\n\n\t\t\treturn `", "`;\n\t\t};\n\n\t\t", ".css = {\n\t\t\tcode: ", ",\n\t\t\tmap: ", "\n\t\t};\n\n\t\tvar warned = false;\n\n\t\t", "\n\t"], ["\n\t\t", "\n\n\t\tvar ", " = {};\n\n\t\t", ";\n\n\t\t", ".data = function() {\n\t\t\treturn ", ";\n\t\t};\n\n\t\t", ".render = function(state, options = {}) {\n\t\t\tvar components = new Set();\n\n\t\t\tfunction addComponent(component) {\n\t\t\t\tcomponents.add(component);\n\t\t\t}\n\n\t\t\tvar result = { head: '', addComponent };\n\t\t\tvar html = ", "._render(result, state, options);\n\n\t\t\tvar cssCode = Array.from(components).map(c => c.css && c.css.code).filter(Boolean).join('\\\\n');\n\n\t\t\treturn {\n\t\t\t\thtml,\n\t\t\t\thead: result.head,\n\t\t\t\tcss: { code: cssCode, map: null },\n\t\t\t\ttoString() {\n\t\t\t\t\treturn html;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t", "._render = function(__result, ctx, options) {\n\t\t\t", "\n\t\t\t__result.addComponent(", ");\n\n\t\t\tctx = Object.assign(", ");\n\n\t\t\t",
        "\n\n\t\t\t",
        "\n\n\t\t\treturn \\`", "\\`;\n\t\t};\n\n\t\t", ".css = {\n\t\t\tcode: ", ",\n\t\t\tmap: ", "\n\t\t};\n\n\t\tvar warned = false;\n\n\t\t", "\n\t"])), compiler.javascript, name, compiler.options.filename && name + ".filename = " + stringify(compiler.options.filename), name, templateProperties.data ? "%data()" : "{}", name, name, name, templateProperties.store && "options.store = %store();", name, initialState.join(', '), computations.map(function (_a) {
        var key = _a.key;
        return "ctx." + key + " = %computed-" + key + "(ctx);";
    }), target.bindings.length && deindent(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject(["\n\t\t\t\tvar settled = false;\n\t\t\t\tvar tmp;\n\n\t\t\t\twhile (!settled) {\n\t\t\t\t\tsettled = true;\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"], ["\n\t\t\t\tvar settled = false;\n\t\t\t\tvar tmp;\n\n\t\t\t\twhile (!settled) {\n\t\t\t\t\tsettled = true;\n\n\t\t\t\t\t", "\n\t\t\t\t}\n\t\t\t"])), target.bindings.join('\n\n')), target.renderCode, name, css.code ? stringify(css.code) : "''", css.map ? stringify(css.map.toString()) : 'null', templateProperties.preload && name + ".preload = %preload;");
    var format = compiler.options.format || 'cjs';
    return compiler.generate(result, compiler.options, { name: name, format: format });
}
function trim(nodes) {
    var start = 0;
    for (; start < nodes.length; start += 1) {
        var node = nodes[start];
        if (node.type !== 'Text')
            break;
        node.data = node.data.replace(/^\s+/, '');
        if (node.data)
            break;
    }
    var end = nodes.length;
    for (; end > start; end -= 1) {
        var node = nodes[end - 1];
        if (node.type !== 'Text')
            break;
        node.data = node.data.replace(/\s+$/, '');
        if (node.data)
            break;
    }
    return nodes.slice(start, end);
}
var templateObject_1$1, templateObject_2;

export default generate;
